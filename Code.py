# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19A-CYj1XWoqNo6DVOvDuLtMnuimydN-m
"""

import random
import time
import math
import matplotlib.pyplot as plt

# ---------------- Disjoint Set (Union-Find) ----------------
class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rx, ry = self.find(x), self.find(y)
        if rx == ry:
            return False
        if self.rank[rx] < self.rank[ry]:
            self.parent[rx] = ry
        elif self.rank[rx] > self.rank[ry]:
            self.parent[ry] = rx
        else:
            self.parent[ry] = rx
            self.rank[rx] += 1
        return True

# ---------------- Kruskal’s Algorithm ----------------
def kruskal(n, edges):
    edges.sort(key=lambda x: x[2])
    ds = DisjointSet(n)
    mst_weight = 0
    for u, v, w in edges:
        if ds.union(u, v):
            mst_weight += w
    return mst_weight

# ---------------- Graph Generation ----------------
def generate_graph(n):
    return [(i, j, random.randint(1, 100)) for i in range(n) for j in range(i+1, n)]

# ---------------- Experimental Runtime ----------------
def experimental_runtime(n):
    edges = generate_graph(n)
    start = time.perf_counter()
    kruskal(n, edges)
    elapsed_ns = (time.perf_counter() - start) * 1e9  # Convert to nanoseconds
    return elapsed_ns, len(edges)

# ---------------- Theoretical Operations ----------------
def theoretical_operations(n):
    m = n*(n-1)//2
    return m * math.log2(n)

# ---------------- Main Experiment ----------------
n_values = [100, 200, 300, 400, 500, 100, 2000, 3000, 4000, 5000, 8000, 10000]
exp_times_ns, theo_values = [], []

# Table Header
print(f"{'n':>8} {'Experimental(ns)':>20} {'Theoretical Operations':>25} {'Scaled Values(ns)':>20}")
print("="*90)

# Collect data
for n in n_values:
    exp_ns, m = experimental_runtime(n)
    theo = theoretical_operations(n)
    exp_times_ns.append(exp_ns)
    theo_values.append(theo)

# ---------------- Scaling ----------------
C = sum(e*t for e,t in zip(exp_times_ns, theo_values)) / sum(t*t for t in theo_values)
theo_scaled = [C*t for t in theo_values]

# Print table
for n, e_ns, t_ops, s_ns in zip(n_values, exp_times_ns, theo_values, theo_scaled):
    print(f"{n:8d} {int(e_ns):20d} {int(t_ops):25d} {int(s_ns):20d}")

print(f"\nScaling constant C = {C:.4f}\n")

# ---------------- Plotting ----------------
plt.figure(figsize=(7,5))
plt.plot(n_values, exp_times_ns, 'ro-', label='Experimental Runtime (ns)')
plt.plot(n_values, theo_scaled, 'b^-', label='Scaled Theoretical Runtime')

plt.xlabel('Number of Vertices (n)')
plt.ylabel('Runtime (ns)')
plt.title('Kruskal’s Algorithm: Experimental vs Scaled Theoretical Runtime')
plt.legend()
plt.grid(True)

# ---------------- Adjust ticks for readability ----------------
# X-axis: show major n values including 1000s
xticks = [100] + [v for i,v in enumerate(n_values) if i%2==0 and v!=100] #Starts with 4000 and rest is autopicked to show a clear x axis
plt.xticks(xticks, rotation=45)
# Y-axis: min, mid, max
y_min = min(exp_times_ns + theo_scaled)
y_max = max(exp_times_ns + theo_scaled)
plt.yticks([int(y_min), int((y_min+y_max)/2), int(y_max)])

plt.tight_layout()
plt.show()